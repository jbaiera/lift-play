<!DOCTYPE html>
<html>
  <head>
    <title>Home</title>
  </head>
  <!--
    The class here in the body tag is important because it identifies the actual main piece
    of HTML that will be used as the starting point for rendering. We point to the "main" id
    which is the div below. This is essentially a way to bootstrap Lift by telling it what tag
    to start with.
   -->
  <body data-lift-content-id="main">

    <!--
      The id for this tag is "main" which means that the above class identifies it as the starting
      point for Lift view processing.

      The class is a Lift directive : "lift:surround?with=default;at=content"
      The first string "lift:" tells the Lift framework to do something.
      The next part "surround" defines which snippet to apply to this content. "surround" is a built in Lift snippet.
      The items after the "?" are the parameters for the snippet:
        Param "with=default" tells "surround" which html file to use as the template.
        Param "at=content" tells "surround" the id of the tag in the template to replace with this content.
    -->
    <div id="main" data-lift="surround?with=bootstrap;at=content">

      <!--
        Here, we invoke the "comet" snippet from Lift.
        Comet is a way to push updates back to the client from the web server by using long timeout http requests.

        The "comet" snippet needs to know which Actor to communicate on the app server. It finds this info in
          the "type" param

        The "comet" snippet then modifies this node by attaching the required javascript that will communicate
          with the expected server side Actor.
      -->
      <div data-lift="comet?type=Chat">
        Some chat messages
        <ul>
          <li>A message</li>
          <li class="clearable">Another message</li>
          <li class="clearable">A third message</li>
        </ul>
      </div>

      <div>
        <!--
          Here, we invoke the "ajax" method on the "form" snippet from Lift.
          This snippet modifies the current html node by setting the form submission to use AJAX.
          The real magic of the form submission is the "chat_in" input.
        -->
        <form data-lift="form.ajax">
          <!--
            Here, we invoke our own custom snippet "ChatIn".
            This snippet of ours modifies the following tag with what to do with the data it has collected
              via JS commands generated by Scala code.

            More directly, our snippet sets the "onSubmit" hook on the tag to send the info to the server,
              and then reset the value inside itself to be empty.

            The submit button doesn't really do anything other than trigger the onSubmit for the form,
              which triggers submission for the form's elements.
            This is the same for if you simply press "enter" while in the text box.
          -->
          <input data-lift="ChatIn" id="chat_in"/>
          <input type="submit" value="Say Something"/>
        </form>

      </div>

    </div>
  </body>
</html>

