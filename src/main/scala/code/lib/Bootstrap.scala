package code.lib

import net.liftweb.common.{Box, Empty, Full}
import net.liftweb.http.js.{JE, JsCmd}
import net.liftweb.http.{LiftRules, NoticeType, S}

import scala.xml.{Text, NodeSeq}

/**
 * A set of utilities for better adapting the built in Lift functionality with the Twitter Bootstrap web library.
 */
object Bootstrap {

  /**
   * This object assists in styling the alert layouts generated by the [[net.liftweb.builtin.snippet.Msgs]].
   *
   * @note This does not work with the [[net.liftweb.builtin.snippet.Msg]] as that snippet renders very
   *       differently.
   */
  object Alerts {

    /**
     * Defines characteristics of the alert level.
     */
    sealed trait AlertLevel {
      private[Bootstrap] def styleClass = "list-group-item alert"
      def glyph: String
      def header: String
      def noticeType: NoticeType.Value
    }

    /**
     * Info level generates clearable events with the standard info background.
     * When passed to the alert functions, the ensuing notification function
     * called is [[S.notice]].
     */
    object Info extends AlertLevel {
      private[Bootstrap] override def styleClass = super.styleClass + " list-group-item-info"
      override def glyph = "info-sign"
      override def header = "Heads Up!"
      override def noticeType = NoticeType.Notice
    }

    /**
     * Warn level generates clearable events with the standard warning background.
     * When passed to the alert functions, the ensuing notification function
     * called is [[S.warning]].
     */
    object Warn extends AlertLevel {
      private[Bootstrap] override def styleClass = super.styleClass + " list-group-item-warning"
      override def glyph = "exclamation-sign"
      override def header = "Warning!"
      override def noticeType = NoticeType.Warning
    }

    /**
     * Error level generates clearable events with the standard info background.
     * When passed to the alert functions, the ensuing notification function
     * called is [[S.error]].
     */
    object Error extends AlertLevel {
      private[Bootstrap] override def styleClass = super.styleClass + " list-group-item-danger"
      override def glyph = "remove-sign"
      override def header = "Oh Snap!"
      override def noticeType = NoticeType.Error
    }

    /**
     * Call this in the Boot class and set it to the [[LiftRules.noticesEffects]]
     * lift rule entry to modify the notice effects.
     *
     * This MUST be configured in the app's Boot.scala or else unexpected behaviour
     * may be experienced.
     *
     * @return A function that maps NoticeTypes and Id's to JS effect functions
     *         that set Bootstrap styling.
     */
    def getNoticeEffects: (Box[NoticeType.Value], String) => Box[JsCmd] = {
      val jsNotice =
        s"""$$('#lift__noticesContainer___notice li')
           |.addClass("${Info.styleClass}")
           |.append('<button type="button" class="close" data-dismiss="alert" aria-label="Close"><span aria-hidden="true">&times;</span></button>')
           |$$('#lift__noticesContainer___notice ul')
           |.addClass("list-group")""".stripMargin

      val jsWarning =
        s"""$$('#lift__noticesContainer___warning li')
           |.addClass("${Warn.styleClass}")
           |.append('<button type="button" class="close" data-dismiss="alert" aria-label="Close"><span aria-hidden="true">&times;</span></button>')
           |$$('#lift__noticesContainer___warning ul')
           |.addClass("list-group")""".stripMargin

      val jsError =
        s"""$$('#lift__noticesContainer___error li')
           |.addClass("${Error.styleClass}")
           |.append('<button type="button" class="close" data-dismiss="alert" aria-label="Close"><span aria-hidden="true">&times;</span></button>')
           |$$('#lift__noticesContainer___error ul')
           |.addClass("list-group")""".stripMargin

      (notice: Box[NoticeType.Value], id: String) => {
        notice match {
          case Full(v) => v match {
            case NoticeType.Notice => Full(JE.JsRaw(jsNotice).cmd)
            case NoticeType.Warning => Full(JE.JsRaw(jsWarning).cmd)
            case NoticeType.Error => Full(JE.JsRaw(jsError).cmd)
          }
          case _ => Empty
        }
      }
    }

    /**
     * Sets a notice at the given alert class.
     * Submit your requests with this to render a notice with glyphicon and header support.
     */
    def !< (alertClass: AlertLevel, message: String): Unit = {
      alert(alertClass, Empty, message)
    }

    /**
     * Sets a notice with the given header as the title at the given alert class.
     * Submit your requests with this to render a notice with glyphicon and header support.
     */
    def !< (alertClass: AlertLevel, header: String, message: String): Unit = {
      alert(alertClass, Full(header), message)
    }

    private def alert(alertClass: AlertLevel, header: Box[String], message: String): Unit = {
      val msg = makeMessage(header, message, alertClass)
      S.appendNotices((alertClass.noticeType, msg, Empty) :: Nil)
    }

    private def makeMessage(header: Box[String], s: String, ac: AlertLevel): NodeSeq =
      Glyphicons.wrap(<strong>{header openOr ac.header}</strong> ++ Text(" "+s), ac.glyph)
  }

  object Glyphicons {
    def glyph(icon: String): NodeSeq = {
      <span class={"glyphicon glyphicon-" + icon}></span>
    }

    def wrap(message: String, icon: String): NodeSeq = {
      <span>{glyph(icon)}&nbsp;{message}</span>
    }

    def wrap(message: NodeSeq, icon: String): NodeSeq = {
      <span>{glyph(icon)}&nbsp;{message}</span>
    }
  }
}
