package code.lib

import net.liftweb.common.{Empty, Box, Full}
import net.liftweb.http.js.{JsCmd, JE}
import net.liftweb.http.{NoticeType, LiftRules, S}

import scala.xml.NodeSeq

/**
 * A set of utilities for better adapting the built in Lift functionality with the Twitter Bootstrap web library.
 */
object Bootstrap {

  /**
   * This object assists in styling the alert layouts generated by the [[net.liftweb.builtin.snippet.Msgs]].
   */
  object Alerts {

    case class AlertID(id: String)

    /**
     * Defines characteristics of the alert level.
     */
    sealed trait AlertLevel {
      /*
       * Todo:
       * Split into multiple traits to allow users to override
       * message building and formatting. Not everyone wants
       * glyphicons, or even potentially the Bootstrap defined
       * styling.
       */
      private[Bootstrap] def styleClass = "list-group-item alert"

      def glyph: String

      def header: String
    }

    /**
     * Info level generates clearable events with the standard info background.
     * When passed to the alert functions, the ensuing notification function
     * called is [[S.notice]].
     */
    object Info extends AlertLevel {
      private[Bootstrap] override def styleClass = super.styleClass + " list-group-item-info"

      override def glyph = "info-sign"

      override def header = "Heads Up!"
    }

    /**
     * Warn level generates clearable events with the standard warning background.
     * When passed to the alert functions, the ensuing notification function
     * called is [[S.warning]].
     */
    object Warn extends AlertLevel {
      private[Bootstrap] override def styleClass = super.styleClass + " list-group-item-warning"

      override def glyph = "exclamation-sign"

      override def header = "Warning!"
    }

    /**
     * Error level generates clearable events with the standard info background.
     * When passed to the alert functions, the ensuing notification function
     * called is [[S.error]].
     */
    object Error extends AlertLevel {
      private[Bootstrap] override def styleClass = super.styleClass + " list-group-item-danger"

      override def glyph = "remove-sign"

      override def header = "Oh Snap!"
    }

    /**
     * Call this in the Boot class and set it to the [[LiftRules.noticesEffects]]
     * lift rule entry to modify the notice effects.
     *
     * This MUST be configured in the app's Boot.scala or else unexpected behaviour
     * may be experienced.
     *
     * @return A function that maps NoticeTypes and Id's to JS effect functions
     *         that set Bootstrap styling.
     */
    def getNoticeEffects: (Box[NoticeType.Value], String) => Full[JsCmd] = {
      val jq = "$"
      val jsNotice =
        s"""$jq('#lift__noticesContainer___notice li')
           |.addClass("${Info.styleClass}")
           |.append('<button type="button" class="close" data-dismiss="alert">×</button>')
           |$jq('#lift__noticesContainer___notice ul')
           |.addClass("list-group")""".stripMargin

      val jsWarning =
        s"""$jq('#lift__noticesContainer___warning li')
           |.addClass("${Warn.styleClass}")
           |.append('<button type="button" class="close" data-dismiss="alert">×</button>')
           |$jq('#lift__noticesContainer___warning ul')
           |.addClass("list-group")""".stripMargin

      val jsError =
        s"""$jq('#lift__noticesContainer___error li')
           |.addClass("${Error.styleClass}")
           |.append('<button type="button" class="close" data-dismiss="alert">×</button>')
           |$jq('#lift__noticesContainer___error ul')
           |.addClass("list-group")""".stripMargin

      /*
       * Todo:
       * Allow a user the possiblity of registering their own (AlertID => Full[JsCmd])
       * entries to handle styling specific to their own needs.
       */
      (notice: Box[NoticeType.Value], id: String) => {
        notice match {
          case Full(v) => v match {
            case NoticeType.Notice => Full(JE.JsRaw(jsNotice).cmd)
            case NoticeType.Warning => Full(JE.JsRaw(jsWarning).cmd)
            case NoticeType.Error => Full(JE.JsRaw(jsError).cmd)
          }
          case _ => Full(JE.JsRaw(jsNotice).cmd)
        }
      }
    }

    /**
     * Sets a notice at the given alert class.
     */
    def ! (alertClass: AlertLevel, message: String): Unit = {
      alert(alertClass, Empty, message)
    }

    /**
     * Sets a notice with the given header as the title at the given alert class.
     */
    def ! (alertClass: AlertLevel, header: String, message: String): Unit = {
      alert(alertClass, Full(header), message)
    }

    /*
     * Todo:
     * When you configure the object in Boot, you should probably associate the AlertID
     * with a specific AlertLevel once and then use that to look up the AlertLevel
     * during the actual !! call. The reason is some goofyness with the fact that
     * AlertLevel needs to be used in both a configuring sense, and a message creation
     * sense. Supposedly, methods with ID's are not coupled with specific notice types
     * in the effects function. Because AlertLevel is used in those places to configure
     * format effects, we should associate an AlertID with with an AlertClass flat out.
     */

    /**
     * Sets a notice at the given alert class with a given id.
     */
    def !! (id: AlertID, alertClass: AlertLevel, message: String): Unit = {
      alert(id, alertClass, Empty, message)
    }

    /**
     * Sets a notice with the given header as the title at the given alert class with a given id.
     */
    def !! (id: AlertID, alertClass: AlertLevel, header: String, message: String): Unit = {
      alert(id, alertClass, Full(header), message)
    }

    private [Bootstrap] def alert(alertClass: AlertLevel, header: Box[String], message: String): Unit = {
      val msg = makeMessage(header, message, alertClass)
      alertClass match {
        case Info => S.notice(msg)
        case Warn => S.warning(msg)
        case Error => S.error(msg)
      }
    }

    private [Bootstrap] def alert(idBox: AlertID, alertClass: AlertLevel, header: Box[String], message: String): Unit = {
      val msg = makeMessage(header, message, alertClass)
      val AlertID(id) = idBox
      alertClass match {
        case Info => S.notice(id, msg)
        case Warn => S.warning(id, msg)
        case Error => S.error(id, msg)
      }
    }

    private [this] def makeMessage(header: Box[String], s: String, ac: AlertLevel): NodeSeq =
      <span>
        <span class={"glyphicon glyphicon-" + ac.glyph}></span> <strong>{header openOr ac.header}</strong> {s}
      </span>
  }
}
